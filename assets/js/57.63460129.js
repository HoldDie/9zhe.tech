(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{696:function(t,a,l){"use strict";l.r(a);var v=l(33),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,l=t._self._c||a;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h3",{attrs:{id:"什么是代码的可测试性？"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#什么是代码的可测试性？"}},[t._v("#")]),t._v(" 什么是代码的可测试性？")]),t._v(" "),l("p",[t._v("粗略地讲，所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架中很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。")]),t._v(" "),l("h3",{attrs:{id:"编写可测试性代码的最有效手段？"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#编写可测试性代码的最有效手段？"}},[t._v("#")]),t._v(" 编写可测试性代码的最有效手段？")]),t._v(" "),l("p",[t._v("依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试的时候，可以通过 mock 的方法解依赖外部服务，这也是我们在编写单元测试的过程中最有技术挑战的地方。")]),t._v(" "),l("h3",{attrs:{id:"常见的-anti-patterns"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#常见的-anti-patterns"}},[t._v("#")]),t._v(" 常见的 Anti-Patterns")]),t._v(" "),l("ul",[l("li",[t._v("代码中包含未决行为逻辑\n"),l("ul",[l("li",[t._v("未决行为逻辑：代码的输出是随机或者说不确定")]),t._v(" "),l("li",[t._v("一般可以对未决行为逻辑进行封装方法")])])]),t._v(" "),l("li",[t._v("滥用可变全局变量\n"),l("ul",[l("li",[t._v("滥用全局变量可能造成，在使用并行执行单元测试时，结果不一致")])])]),t._v(" "),l("li",[t._v("滥用静态方法\n"),l("ul",[l("li",[t._v("静态方法和静态变量类似，只有这个静态方法执行耗时太长、依赖外部资源、逻辑复杂、行为未决等情况下，我们才需要再单元测试中 mock 这个静态方法。")])])]),t._v(" "),l("li",[t._v("使用复杂的继承关系\n"),l("ul",[l("li",[t._v("如果我们利用组合而非继承来组织类之间的关系，类之间的结构层次比较扁平，在编写单元测试的时候，只需要 mock 类所组合依赖的对象即可。")])])]),t._v(" "),l("li",[t._v("高度耦合的代码\n"),l("ul",[l("li",[t._v("如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那我们在编写单元测试的时候，可能需要 mock 这十几个依赖的对象。")]),t._v(" "),l("li",[t._v("不管是从代码设计的角度来说，还是从编写单元测试的角度来说，这都是不合理的。")])])])])])}),[],!1,null,null,null);a.default=_.exports}}]);