(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{665:function(t,e,r){"use strict";r.r(e);var a=r(33),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:"迭代器模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#迭代器模式"}},[t._v("#")]),t._v(" 迭代器模式")]),t._v(" "),r("ul",[r("li",[t._v("迭代器模式（Iterator Design Pattern），也叫作游标模式（Cursor Design Pattern）。")]),t._v(" "),r("li",[t._v("一个完整的迭代器模式一般会涉及容器和容器迭代器两部分内容，为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。")]),t._v(" "),r("li",[t._v("迭代器模式将集合对象的遍历操作从集合类中拆出来，放到迭代器类中，让两者的职责更加单一。")]),t._v(" "),r("li",[t._v("迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HoldDie/img/20201124160624.jpg",alt:"cb72b5921681ac13d4fc05237597d2ec"}})]),t._v(" "),r("h3",{attrs:{id:"理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#理解"}},[t._v("#")]),t._v(" 理解")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("对于迭代器的设计，就是在原本本身的正常的 add 和 remove 功能之外，当需要遍历的时候，我们使用 Iteration 进行快照。")])]),t._v(" "),r("li",[r("p",[t._v("快照可以有两种方式")]),t._v(" "),r("ul",[r("li",[t._v("第一种方式，在每次创建迭代器的时候都把原先的数据复制一份到迭代器中，这样迭代器中的修改和之前原数据就么有关系，完成自己迭代操作。")]),t._v(" "),r("li",[t._v("第二种方式，如果数据量比较大，此时每创建一个迭代器空间开销比较大，如何我们取巧，在每个数据中不仅有数据，还添加一个创建时间和结束时间，这样在创建快照的时候，我们自己有一个快照时间，然后，只有在 createTime < snapshotTime < endTime 区间的数据才是本次迭代的数据。")])])])])])}),[],!1,null,null,null);e.default=s.exports}}]);