(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{654:function(t,l,e){"use strict";e.r(l);var i=e(33),v=Object(i.a)({},(function(){var t=this,l=t.$createElement,e=t._self._c||l;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"中介模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#中介模式"}},[t._v("#")]),t._v(" 中介模式")]),t._v(" "),e("ul",[e("li",[t._v("Mediator Design Pattern")]),t._v(" "),e("li",[t._v("中介模式定义了一个单独的（中介）对象，来封装一组对象间的交互，将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。")]),t._v(" "),e("li",[t._v("中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。")])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/HoldDie/img/20201125083359.jpg",alt:"4376d541bf17a029f37aa76009ef3a9f"}})]),t._v(" "),e("p",[t._v("中介模式 VS 观察者模式")]),t._v(" "),e("ul",[e("li",[t._v("观察者模式：\n"),e("ul",[e("li",[t._v("在单进程中，需要观察者注册到被观察者中，被观察者状态更新需要调用观察者的 update 方法。")]),t._v(" "),e("li",[t._v("在跨进程中，可以利用消息队列实现彻底解耦，观察者和被观察者只需要跟消息队列交互，观察者完全不知道被观察者的存在。")]),t._v(" "),e("li",[t._v("尽管一个参与者既可以是观察者，同时也可以是被观察者，但大部分情况下交互往往都是单向的。")])])]),t._v(" "),e("li",[t._v("中介模式\n"),e("ul",[e("li",[t._v("只要当参与者之间的交互关系错综复杂，维护成本很高的时候，我们考虑使用中介模式。")]),t._v(" "),e("li",[t._v("如果一个参与者状态的改变，其他参与者执行的操作有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者的方法，来实现顺序的控制，而观察者模式是无法实现这样的顺序要求的。")])])])])])}),[],!1,null,null,null);l.default=v.exports}}]);