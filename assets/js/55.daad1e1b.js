(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{692:function(t,a,l){"use strict";l.r(a);var v=l(33),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,l=t._self._c||a;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h2",{attrs:{id:"重构目的：为什么需要重构？"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#重构目的：为什么需要重构？"}},[t._v("#")]),t._v(" 重构目的：为什么需要重构？")]),t._v(" "),l("ul",[l("li",[t._v("重构是一种对软件内部接口的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。")]),t._v(" "),l("li",[t._v("重构是避免过度设计的有效手段。")])]),t._v(" "),l("h2",{attrs:{id:"重构的对象：到底重构什么（what）？"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#重构的对象：到底重构什么（what）？"}},[t._v("#")]),t._v(" 重构的对象：到底重构什么（what）？")]),t._v(" "),l("ul",[l("li",[t._v("大型重构")]),t._v(" "),l("li",[l("ul",[l("li",[t._v("主要针对：系统、模块、代码结构、类与类之间的关系等的重构。")]),t._v(" "),l("li",[t._v("重构手段有：分层、模块化、解耦、抽象可复用组件等等。")])])]),t._v(" "),l("li",[t._v("小型重构")]),t._v(" "),l("li",[l("ul",[l("li",[t._v("主要针对：类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。")]),t._v(" "),l("li",[t._v("重构手段：熟练掌握各种编码规范。")])])])]),t._v(" "),l("h2",{attrs:{id:"重构的时机：什么时候重构（when）？"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#重构的时机：什么时候重构（when）？"}},[t._v("#")]),t._v(" 重构的时机：什么时候重构（when）？")]),t._v(" "),l("ul",[l("li",[t._v("最好的时机：持续重构，梳理持续重构意识。")])]),t._v(" "),l("h2",{attrs:{id:"重构的方法：又该如何重构（how）？"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#重构的方法：又该如何重构（how）？"}},[t._v("#")]),t._v(" 重构的方法：又该如何重构（how）？")]),t._v(" "),l("ul",[l("li",[t._v("大型重构，需要组织、有计划地进行，分阶段地小步快跑，时刻让代码处于一个可运行的状态，可以有条不紊地分阶段来进行，每个阶段完成一部分代码的重构，然后提交、测试、运行。")]),t._v(" "),l("li",[t._v("小规模的重构，因为影响范围小，改动耗时短，可以随时进行。")])])])}),[],!1,null,null,null);a.default=_.exports}}]);